class Collection{constructor(r){this.arr=[...r]}all(){return this.arr}average(){return this.arr.reduce((r,e)=>r+e)/this.arr.length}avg(){return this.arr.reduce((r,e)=>r+e)/this.arr.length}chunk(r){const e=[];let t,n,o;for(n=this.arr.length,t=0;t<n;t+=r)o=this.arr.slice(t,t+r),e.push(o);return new Collection(e)}collapse(){const r=[];return this.arr.map(e=>{e.map(e=>{r.push(e)})}),new Collection(r)}collect(){return new Collection(this.arr)}concat(r){const e=this.arr.concat(r);return new Collection(e)}contains(r){if("function"==typeof r)return this.arr.every((e,t,n)=>r(e,t,n));if("object"==typeof r){let e;return r.every(r=>e=this.arr.includes(r))}{let e;return e=this.arr.includes(r)}}containsLoose(r){if("function"==typeof r)return this.arr.some((e,t,n)=>r(e,t,n));if("object"==typeof r){const e=new Collection(this.arr);let t;return r.every(r=>(t=e.includesLoose(r))||!isNaN(r)&&((t=e.includesLoose(parseFloat(r)))||(t=e.includesLoose(String(r)))))}{const e=new Collection(this.arr);let t;return(t=e.includesLoose(r))||!isNaN(r)&&((t=e.includesLoose(parseFloat(r)))||(t=e.includesLoose(String(r))))}}count(){return this.arr.length}eachSpread(r){var e=[],t=function(n){if(Array.isArray(n))for(var o in n)t(n[o]);else e.push(r(n))};return this.arr.forEach(t),new Collection(e)}countOccurrences(r){return this.arr.reduce((e,t)=>t===r?e+1:e,0)}countOccurrencesLoose(r){return this.arr.reduce((e,t)=>t==r?e+1:e,0)}diff(r){if(r instanceof Collection){const e=this.arr.filter(e=>!r.contains(e));return new Collection(e)}{const e=new Collection(r),t=this.arr.filter(r=>!e.contains(r));return new Collection(t)}}diffLoose(r){if(r instanceof Collection){const e=this.arr.filter(e=>!r.containsLoose(e));return new Collection(e)}{const e=new Collection(r),t=this.arr.filter(r=>!e.containsLoose(r));return new Collection(t)}}duplicates(){const r=(r,e,t)=>{let n;for(;t--;)n=r.indexOf(e),r.splice(n,1)},e=[],t=new Collection(this.arr);let n,o,s;for(s=t.arr.length;s--;)n=t.arr[s],(o=t.countOccurrences(t.arr[s]))>1&&(e.push(t.arr[s]),r(t.arr,t.arr[s],o));return new Collection(e.reverse())}duplicatesLoose(){const r=(r,e,t)=>{let n;for(;t--;){n=new Collection(r).indexOfLoose(e),r.splice(n,1)}},e=[],t=new Collection(this.arr);let n,o,s;for(s=t.arr.length;s--;)n=t.arr[s],(o=t.countOccurrencesLoose(t.arr[s]))>1&&(e.push(t.arr[s]),r(t.arr,t.arr[s],o));return new Collection(e.reverse())}each(r){const e=[];let t;t=this.arr.length;for(let n=0;n<t;n++)e.push(r(this.arr[n],n,this.arr));return new Collection(e)}eachSpread(r){const e=[];let t;t=this.arr.length;for(let n=0;n<t;n++)for(let t=0;t<this.arr[n].length;t++)e.push(r(this.arr[n][t],[n,t],this.arr,this.arr[n]));return new Collection(e)}eachSpreadDeep(r){const e=[],t=function(n){if(Array.isArray(n))for(var o in n)t(n[o]);else e.push(r(n))};return this.arr.forEach(t),new Collection(e)}indexOfLoose(r){let e;const t=this.arr.map(r=>isNaN(r)?r.toLowerCase():r);return isNaN(r)&&(r=r.toLowerCase()),-1!==(e=t.indexOf(r))?e:isNaN(r)?-1:-1!==(e=t.indexOf(parseFloat(r)))?e:e=t.indexOf(String(r))}includesLoose(r){let e;const t=this.arr.map(r=>isNaN(r)?r.toLowerCase():r);return isNaN(r)&&(r=r.toLowerCase()),(e=t.includes(r))||(isNaN(r)?e:(e=t.includes(parseFloat(r)))||(e=t.includes(String(r))))}}const collect=r=>new Collection(r);
